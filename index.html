<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Brille — Recovery</title>
<style>
  body{font-family:system-ui,Arial,sans-serif;background:#111;color:#eee;padding:16px}
  button{display:block;width:100%;padding:12px;margin:8px 0;border-radius:8px;border:none;font-size:15px;cursor:pointer}
  .log{background:#000;padding:10px;height:420px;overflow:auto;font-family:monospace;font-size:12px;white-space:pre-wrap}
</style>
</head>
<body>
  <h2>Brille — Recovery Tool</h2>
  <p>Schließe Shining-App, lade Brille kurz. Nutze Bluefy oder GitHub Pages.</p>
  <button id="btnConnect">Connect Brille</button>
  <button id="btnStart" disabled>Start Recovery</button>
  <button id="btnStop" disabled>Stop Recovery</button>
  <button onclick="clearLog()">Clear Log</button>
  <div class="log" id="log">Log startet...</div>

<script>
const GLASS_SERVICE_FFF0 = '0000fff0-0000-1000-8000-00805f9b34fb';
const KNOWN = [
  'd44bc439-abfd-45a2-b575-925416129600',
  'd44bc439-abfd-45a2-b575-925416129601',
  'd44bc439-abfd-45a2-b575-92541612960a',
  'd44bc439-abfd-45a2-b575-92541612960b'
];

let server = null;
let candidates = []; // characteristic objects
let running = false;

function log(s){ const el=document.getElementById('log'); el.textContent = `[${new Date().toLocaleTimeString()}] ${s}\n` + el.textContent; console.log(s); }
function clearLog(){ document.getElementById('log').textContent=''; }

document.getElementById('btnConnect').addEventListener('click', connect);
document.getElementById('btnStart').addEventListener('click', ()=>{ running=true; document.getElementById('btnStop').disabled=false; document.getElementById('btnStart').disabled=true; runRecovery(); });
document.getElementById('btnStop').addEventListener('click', ()=>{ running=false; document.getElementById('btnStop').disabled=true; document.getElementById('btnStart').disabled=false; });

async function connect(){
  try {
    log('requestDevice (acceptAllDevices, optional FFF0)...');
    const device = await navigator.bluetooth.requestDevice({ acceptAllDevices:true, optionalServices:[GLASS_SERVICE_FFF0] });
    log('Ausgewählt: ' + (device.name||device.id));
    device.addEventListener('gattserverdisconnected', ()=>{ log('Brille: disconnected'); candidates=[]; server=null; document.getElementById('btnStart').disabled=true; });
    server = await device.gatt.connect();
    log('GATT connected. Enumerating services...');
    const services = await server.getPrimaryServices();
    for (const s of services){
      try {
        const chars = await s.getCharacteristics();
        for (const c of chars){
          log(`Service ${s.uuid} Char ${c.uuid} props ${JSON.stringify(c.properties)}`);
          if (c.properties.write || c.properties.writeWithoutResponse || KNOWN.includes(c.uuid)) candidates.push(c);
        }
      } catch(e){ log('Char read error: ' + (e&&e.message)); }
    }
    if (candidates.length){ log('Candidates: ' + candidates.map(c=>c.uuid).join(', ')); document.getElementById('btnStart').disabled=false; }
    else log('Keine candidate characteristics gefunden.');
  } catch(e){ log('Connect Fehler: ' + (e && (e.name + ' / ' + e.message))); }
}

function checksum(bytes){ let s=0; for(const b of bytes) s=(s+b)&0xFF; return s; }

async function writeAll(payload){
  for(const c of candidates){
    try{
      await c.writeValue(payload);
      log('Wrote ' + hex(payload) + ' -> ' + c.uuid);
    }catch(e){
      log('Write error ' + c.uuid + ': ' + (e && e.message));
    }
    // small pause
    await sleep(120);
  }
}

async function runRecovery(){
  if (!candidates.length){ log('No candidates, abort.'); running=false; document.getElementById('btnStart').disabled=false; return; }
  log('Starting recovery loop; will send multiple patterns.');
  const patterns = [
    new Uint8Array([0x01]),
    new Uint8Array([0x02]),
    new TextEncoder().encode('A'),
    new TextEncoder().encode('B'),
    new Uint8Array([0xAA,0x55,0x01]),
    new Uint8Array([0xAA,0x55,0x01,0x01, checksum([0xAA,0x55,0x01,0x01])]),
    new Uint8Array([0x7E,0x03,0x01, checksum([0x7E,0x03,0x01])]),
    new Uint8Array([0x55,0xAA,0x01]),
    new Uint8Array([0x00]),
    new Uint8Array([0xFF]),
    new Uint8Array([0x01,0x02,0x03])
  ];
  while(running){
    for(const p of patterns){
      if(!running) break;
      await writeAll(p);
    }
    // repeat small burst of single bytes 0x01/0x02
    for(let i=0;i<5 && running;i++){
      await writeAll(new Uint8Array([0x01])); await sleep(80);
      await writeAll(new Uint8Array([0x02])); await sleep(80);
    }
    log('One recovery cycle finished; pause 1.5s');
    await sleep(1500);
  }
  log('Recovery stopped by user.');
}

function hex(u8){ return Array.from(u8).map(x=>x.toString(16).padStart(2,'0')).join(' '); }
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
</script>
</body>
</html>
