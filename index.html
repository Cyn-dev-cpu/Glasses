<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Force Writes — Try Every Service/Characteristic</title>
<style>
  body{font-family:system-ui,Arial,Helvetica,sans-serif;background:#111;color:#eee;padding:14px}
  h1{font-size:18px;margin:0 0 8px}
  button{display:block;width:100%;padding:12px;margin:8px 0;border-radius:8px;border:none;font-size:15px;cursor:pointer}
  .btnPrimary{background:#268bd2;color:#fff}
  .btnWarn{background:#d33682;color:#fff}
  .log{background:#000;padding:10px;height:380px;overflow:auto;font-family:monospace;font-size:12px;white-space:pre-wrap;border:1px solid #222}
  .small{font-size:13px;color:#bbb}
  .row{display:flex;gap:8px}
  input[type="text"]{flex:1;padding:10px;border-radius:6px;border:1px solid #333;background:#0f1113;color:#eee}
</style>
</head>
<body>
  <h1>Force Writes — Try Every Service/Characteristic</h1>
  <p class="small">This page connects to your glasses, enumerates all services/characteristics and attempts a small set of test payloads on each characteristic once. Close the Shining app first. Use Chrome on Android or Bluefy on iOS.</p>

  <div class="row">
    <button class="btnPrimary" id="btnConnect">1) Connect Device</button>
    <button class="btnWarn" id="btnStop" disabled>Stop</button>
  </div>

  <div style="margin-top:6px" class="row">
    <input id="customHex" type="text" placeholder="Optional extra hex payload (e.g. AA 55 01 01)" />
    <button id="btnAdd" class="btnPrimary">Add</button>
  </div>

  <button class="btnPrimary" id="btnRun" disabled>2) Force write once through every characteristic</button>

  <div class="log" id="log">Log starts...</div>

<script>
/*
  Force-all script
  - connect to a device (acceptAllDevices)
  - enumerate all primary services and characteristics
  - try to write a small set of payloads once to each characteristic (if allowed)
  - log successes/errors for each characteristic
*/
let device = null;
let server = null;
let allChars = []; // {serviceUuid, char}
let running = false;

// default payloads (small & safe-ish)
const defaultPayloads = [
  new Uint8Array([0x01]),
  new Uint8Array([0x02]),
  new Uint8Array([0x54,0x52,0x00,0x41]) // the ManufacturerData you posted earlier
];

let payloads = defaultPayloads.slice();

function log(msg){
  const el = document.getElementById('log');
  el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + el.textContent;
  console.log(msg);
}

document.getElementById('btnAdd').addEventListener('click', ()=>{
  const hex = document.getElementById('customHex').value.trim();
  if (!hex) { log('No hex entered'); return; }
  const arr = hexToBytes(hex);
  if (!arr) { log('Invalid hex'); return; }
  payloads.push(arr);
  log('Added custom payload: ' + toHex(arr));
  document.getElementById('customHex').value = '';
});

document.getElementById('btnConnect').addEventListener('click', async ()=>{
  try {
    log('Requesting device (acceptAllDevices)...');
    device = await navigator.bluetooth.requestDevice({ acceptAllDevices: true, optionalServices: [] });
    log('Selected: ' + (device.name || device.id));
    device.addEventListener('gattserverdisconnected', () => {
      log('Device disconnected');
      server = null;
      allChars = [];
      document.getElementById('btnRun').disabled = true;
      document.getElementById('btnStop').disabled = true;
    });
    server = await device.gatt.connect();
    log('GATT connected. Enumerating services...');
    const services = await server.getPrimaryServices();
    log('Found ' + services.length + ' primary service(s).');
    allChars = [];
    for (const s of services){
      log('Service: ' + s.uuid);
      try {
        const chars = await s.getCharacteristics();
        for (const c of chars){
          log('  Char: ' + c.uuid + ' props: ' + JSON.stringify(c.properties));
          allChars.push({serviceUuid: s.uuid, char: c});
        }
      } catch(e){
        log('  -> Error reading characteristics for ' + s.uuid + ': ' + (e && (e.message || e.name)));
      }
    }
    if (allChars.length) {
      log('Total characteristics found: ' + allChars.length);
      document.getElementById('btnRun').disabled = false;
    } else {
      log('No characteristics found.');
    }
  } catch(e){
    log('Connect error: ' + (e && (e.name + ' / ' + e.message)));
  }
});

document.getElementById('btnRun').addEventListener('click', async ()=>{
  if (!server || !allChars.length) { log('Not connected or no chars'); return; }
  running = true;
  document.getElementById('btnStop').disabled = false;
  document.getElementById('btnRun').disabled = true;
  log('Starting force-write pass: ' + payloads.length + ' payload(s) x ' + allChars.length + ' characteristic(s).');
  for (const entry of allChars){
    if (!running) break;
    const c = entry.char;
    log('--- Trying char ' + c.uuid + ' (service ' + entry.serviceUuid + ') ---');
    // Try each payload once for this characteristic
    for (const p of payloads){
      if (!running) break;
      try {
        // attempt write with the standard API
        await c.writeValue(p);
        log('WROTE ' + toHex(p) + ' -> ' + c.uuid);
      } catch(e){
        // some platforms may require writeWithoutResponse - try fallback
        log('Write failed (with writeValue) on ' + c.uuid + ' : ' + (e && (e.message || e.name)));
        if (c.properties && c.properties.writeWithoutResponse) {
          try {
            if (typeof c.writeValueWithoutResponse === 'function') {
              await c.writeValueWithoutResponse(p);
              log('WROTE (no response) ' + toHex(p) + ' -> ' + c.uuid);
            } else {
              log('No writeWithoutResponse function available in this browser for ' + c.uuid);
            }
          } catch(e2){
            log('writeWithoutResponse also failed on ' + c.uuid + ' : ' + (e2 && (e2.message||e2.name)));
          }
        }
      }
      // short pause so device can react and to avoid flooding
      await sleep(160);
    }
  }
  log('Force-write pass finished. Check device for any visual or behavioral changes.');
  running = false;
  document.getElementById('btnStop').disabled = true;
  document.getElementById('btnRun').disabled = false;
});

document.getElementById('btnStop').addEventListener('click', ()=>{
  running = false;
  log('User requested stop. Stopping after current write.');
  document.getElementById('btnStop').disabled = true;
  document.getElementById('btnRun').disabled = false;
});

function hexToBytes(hex){
  const cleaned = hex.replace(/[^0-9a-fA-F]/g,'');
  if (cleaned.length % 2) return null;
  const u = new Uint8Array(cleaned.length/2);
  for (let i=0;i<cleaned.length;i+=2) u[i/2] = parseInt(cleaned.substr(i,2),16);
  return u;
}
function toHex(u8){
  return Array.from(u8).map(b=>b.toString(16).padStart(2,'0')).join(' ');
}
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

</script>
</body>
</html>
